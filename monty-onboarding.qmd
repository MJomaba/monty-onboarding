---
title: "monty-onboarding"
author: "Marc Baguelin"
format: revealjs
editor: visual
---

## Background

```{r setup}
library(monty)
```

- The development of **dust** and **mcstate** were triggered by discussion between the epi and software engineering team

- Creation was motivated with real-time fitting of stochastic discrete model

- *dust* deals with efficient parallel, *mcstate* was an inference-for-odin-model package

- Developed during the pandemic and with a focus on Sequential Monte Carlo (SMC aka particle filter)

- Workhorse algorithm pMCMC with bootstrap

- More ideas have emerged (e.g. adaptive algorithm, nested hierarchical fittin, HMC, parallel tempering), but hindered by initial architecture

## What we call models?

:::: {.columns}

::: {.column width="45%"}
SimCity models

![](images/sim_city_models.webp){fig-align="left" style="position: absolute; bottom: 0; left: 0;" width=30%}
:::

::: {.column width="10%"}
<!-- empty column to create gap -->
:::

::: {.column width="45%"}
Statistical models
:::

::::

## A modular approach

![odin playing with duplo bricks](images/odin-monty-duplo.webp){#fig-odin-duplo fig-alt="ALT" width=30%}

## The Basic Idea

Draw samples from a model using Markov Chain Monte Carlo methods. To do this you will need:

1. A **model**: 
   - A `monty_model()` object 
   - Computes a log probability density 
   - May compute gradient of the log density or sample directly from parameter space.

2. A **sampler**: 
   - A method of drawing samples from the model’s distribution.
   - Simplest sampler is `monty_sampler_random_walk()`, which implements a simple Metropolis algorithm.

3. A **runner**: 
   - Controls how chains are run (e.g., in sequence or in parallel).

## Composability

- The system is **composable**: 
  - Define a model for likelihood
  - Define another model for prior 
  - Choose a sampler and runner.
  
- `monty_model()` is flexible but not user-friendly. A high-level interface will help wrap models from other packages (e.g., [dust](https://mrc-ide.github.io/dust), [odin](https://mrc-ide.github.io/odin)).

## An Example

> Tools like **stan**, **bugs**, **jags** are generally better. This example shows a simple model to demonstrate the approach in **monty**.

```{r}
set.seed(1)
data <- local({
  n <- 60
  weight <- rnorm(n, 50, 6.5)
  height <- 114 + weight * 0.9 + rnorm(60, sd = 3)
  data.frame(height, weight)
})
```

```{r}
head(data)
plot(height ~ weight, data)
```

## Simple Likelihood

A simple likelihood modelled as normally distributed departures from a linear relationship with weight.

```{r, echo=TRUE}
fn <- function(a, b, sigma, data) {
  mu <- a + b * data$weight
  sum(dnorm(data$height, mu, sigma, log = TRUE))
}
```

## Wrapping Likelihood

Wrap the density function in a `monty_model`. The `data` argument is “fixed” and passed as the `fixed` argument.

```{r}
likelihood <- monty_model_function(fn, fixed = list(data = data))
likelihood
```

## Defining a Prior

Priors are defined using the `monty_dsl`:

```{r}
prior <- monty_dsl({
  a ~ Normal(178, 100)
  b ~ Normal(0, 10)
  sigma ~ Uniform(0, 50)
})
prior
```

## Posterior Distribution

Combine the likelihood and prior into a posterior distribution. This can be done using the `+` operator.

```{r}
posterior <- likelihood + prior
posterior
```

## Sampler Setup

Construct a sensible initial variance-covariance matrix and define a random walk sampler.

```{r}
vcv <- rbind(c(4.5, -0.088, 0.076),
             c(-0.088, 0.0018, -0.0015),
             c(0.076, -0.0015, 0.0640))
sampler <- monty_sampler_random_walk(vcv = vcv)
```

## Running the Sampler

Run the sampler to draw 2000 samples across 4 chains.

```{r}
samples <- monty_sample(posterior, sampler, 2000, initial = c(114, 0.9, 3),
                        n_chains = 4)
```

## Visualisation

You can plot the log posterior density over time:

```{r}
matplot(samples$density, type = "l", lty = 1,
        xlab = "log posterior density", ylab = "sample", col = "#00000055")
```

## Parameter Estimation

Estimate the posterior densities of parameters `a`, `b`, and `sigma`.

```{r}
par(mfrow = c(1, 3))
plot(density(samples$pars["a", , ]), main = "a")
abline(v = 114, col = "red")
plot(density(samples$pars["b", , ]), main = "b")
abline(v = 0.9, col = "red")
plot(density(samples$pars["sigma", , ]), main = "sigma")
abline(v = 3, col = "red")
```

## Further Tools

Convert the samples for use with other tools:

- `coda::as.mcmc.list()` for MCMC
- `posterior::as_draws_df()` for further analysis

See `vignette("samplers")` for more details.

