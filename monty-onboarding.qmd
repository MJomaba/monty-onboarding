---
title: "monty onboarding"
author: "Marc Baguelin"
format: revealjs
editor: visual
---

# Background

## dust and mcstate

```{r setup}
library(monty)
```

- *dust* & *mcstate* triggered by epi + software team discussions
- Motivated by real-time fitting of stochastic model
- *dust* deals with efficient parallel computation
- *mcstate* was an inference-for-odin-model package

## More on mcstate

- Developed during the pandemic (technical debt)
- Focus on Sequential Monte Carlo (SMC aka particle filter)
- Workhorse algorithm pMCMC with bootstrap

## Beyond the "discrete-stochastic-odin" architecture

- More ideas have emerged since 
  - adaptive algorithm
  - nested hierarchical fitting
  - HMC
  - parallel tempering
- Hindered by *mcstate* architecture

# monty general principles

## What do we call models?

:::::: columns
::: {.column width="45%"}
**SimCity models**

Input (parameters) delivers real-life outputs

![](images/sim_city_models.webp){fig-align="left" style="position: absolute; bottom: 0; left: 0;" width="30%"}
:::

::: {.column width="10%"}
<!-- empty column to create gap -->
**vs**
:::

::: {.column width="45%"}
**Statistical models**

Abstract (parameter) space with a density function

!["An image of a simple statistical density model but in high dimension"](images/density_model.webp){fig-align="left" style="position: absolute; bottom: 0; left: 1200;" width="40%"}
:::
::::::

## A modular approach

![odin playing with duplo bricks](images/odin-monty-duplo.webp){#fig-odin-duplo fig-alt="ALT" width="30%"}

## The Basic Idea

Draw samples from a model using Markov Chain Monte Carlo methods. To do this you will need:

1.  A **model**:
    -   A `monty_model()` object
    -   Computes a log probability density
    -   May compute gradient of the log density or sample directly from parameter space.
2.  A **sampler**:
    -   A method of drawing samples from the model’s distribution.
    -   Simplest sampler is `monty_sampler_random_walk()`, which implements a simple Metropolis algorithm.
3.  A **runner**:
    -   Controls how chains are run (e.g., in sequence or in parallel).

## Composability

-   The system is **composable**:
    -   Define a model for likelihood
    -   Define another model for prior
    -   Choose a sampler and runner.
-   `monty_model()` is flexible but not user-friendly. A high-level interface will help wrap models from other packages (e.g., [dust](https://mrc-ide.github.io/dust), [odin](https://mrc-ide.github.io/odin)).

## An Example

> Tools like **stan**, **bugs**, **jags** are generally better. This example shows a simple model to demonstrate the approach in **monty**.

```{r, echo=TRUE}
set.seed(1)
data <- local({
  n <- 60
  weight <- rnorm(n, 50, 6.5)
  height <- 114 + weight * 0.9 + rnorm(60, sd = 3)
  data.frame(height, weight)
})
```

```{r, echo=TRUE}
head(data)
plot(height ~ weight, data)
```

## Simple Likelihood

A simple likelihood modelled as normally distributed departures from a linear relationship with weight.

```{r, echo=TRUE}
fn <- function(a, b, sigma, data) {
  mu <- a + b * data$weight
  sum(dnorm(data$height, mu, sigma, log = TRUE))
}
```

## Wrapping Likelihood

Wrap the density function in a `monty_model`. The `data` argument is “fixed” and passed as the `fixed` argument.

```{r, echo=TRUE}
likelihood <- monty_model_function(fn, fixed = list(data = data))
likelihood
```

## Defining a Prior

Priors are defined using the `monty_dsl`:

```{r, echo=TRUE}
prior <- monty_dsl({
  a ~ Normal(178, 100)
  b ~ Normal(0, 10)
  sigma ~ Uniform(0, 50)
})
prior
```

## Posterior Distribution

Combine the likelihood and prior into a posterior distribution. This can be done using the `+` operator.

```{r, echo=TRUE}
posterior <- likelihood + prior
posterior
```

## Sampler Setup

Construct a sensible initial variance-covariance matrix and define a random walk sampler.

```{r, echo=TRUE}
vcv <- rbind(c(4.5, -0.088, 0.076),
             c(-0.088, 0.0018, -0.0015),
             c(0.076, -0.0015, 0.0640))
sampler <- monty_sampler_random_walk(vcv = vcv)
```

## Running the Sampler

Run the sampler to draw 2000 samples across 4 chains.

```{r, echo=TRUE}
samples <- monty_sample(posterior, sampler, 2000, initial = c(114, 0.9, 3),
                        n_chains = 4)
```

## Visualisation

You can plot the log posterior density over time:

```{r, echo=TRUE}
matplot(samples$density, type = "l", lty = 1,
        xlab = "log posterior density", ylab = "sample", col = "#00000055")
```

## Parameter Estimation

Estimate the posterior densities of parameters `a`, `b`, and `sigma`.

```{r, echo=TRUE}
par(mfrow = c(1, 3))
plot(density(samples$pars["a", , ]), main = "a")
abline(v = 114, col = "red")
plot(density(samples$pars["b", , ]), main = "b")
abline(v = 0.9, col = "red")
plot(density(samples$pars["sigma", , ]), main = "sigma")
abline(v = 3, col = "red")
```

## Further Tools

Convert the samples for use with other tools:

-   `coda::as.mcmc.list()` for MCMC
-   `posterior::as_draws_df()` for further analysis

See `vignette("samplers")` for more details.

# Tidying up odin and dust
